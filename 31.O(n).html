<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 다음 배열 내장함수의 시간 복잡도가 O(1)이 아닌 것을 모두 고르시오.

      //        1)  arr[i]
      //           : 값을 읽는 것은 O(1)이다
      //        2)  arr.push(5)
      //           : 배열에 마지막에 값을 추가하는 것은 O(1)이다
      // O(n)   3)  arr.slice()
      //           : 배열 원소 중 특정 구간에 해당하는 것을 추출
      //             배열.slice(1,3)=배열에서 인덱스 1번값에서부터 3번값 전까지 출력
      //             ->slice의 경우 배열을 복사한다.
      //              복사하기 위해서는 빈 값을 만들고 원래 값을 돌면서 push작업을 해준다
      //        4)  arr.pop()
      //           : 배열에서 마지막 원소를 제거한 후에 이를 리턴함

      var jobs = ["programmer", "designer", "planner"];
      var job = jobs.pop();
      alert(job); //  'planner'
      alert(jobs); //  ['programmer', 'designer'], 원본 jobs의 값이 변경 되었다.

      // O(n)   5)  arr.includes(5)
      //           :includes함수는 특정 문자열이 포함하는지 확인하는 함수다
      //            포함되면  true, 없으면 false 를 반환한다
      //                const a = "반갑습니다.";
      //                const b = "다";
      //                const c = a.includes(b);=>c를 출력하면 true 나옴
      //            ->처음 값부터 하나씩 다 찾으면서 값이 들어있는지 확인하기 때문에 O(n)이다

      // 빅오
      // - 무언가를 실행하는데 필요한 단계수를 나타냄
      // - 예를 들어 단계수가 1이면 아주 빠르고 100이면 느린 것
      // - O(1) :"빅 오 1" 이라고 읽고 한단계가 걸린다는 것이다. O(n)은 '빅오엔'
      // - 배열에서 읽기는 O(1)이다. 컴퓨터는 인덱스를 통해 바로 값을 읽을 수 있다
      // - 배열의 마지막에 값을 삽입하는 것도 O(1)이다
      // - 중간에 넣거나 뺴는 것은 O(1)이 아니다.
      //   넣기 위해 값을 미루거나 삭제하고 난 뒤에 중간에 값을 땡겨와야 하는 과정이 있기때문
    </script>
  </body>
</html>
